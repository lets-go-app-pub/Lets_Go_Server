//
// Created by jeremiah on 5/8/21.
//
#pragma once

#include <functional>
#include <string>

enum class CallDataCommandTypes {
    INITIALIZE, //response is for the initialization
    READ, //response is from a Read()
    END_OF_VECTOR_WRITES, //response is from a Write()
    WRITE_WITH_VECTOR_ELEMENTS_REMAINING, //response is from a Write()
    ALARM_QUEUE_WRITE_AT_END, //response is from a Write() generated by a send_write_to_back_of_queue_alarm() call
    FINISH, //response is from a Finish()
    END_STREAM_ALARM_CALLED, //response is from the alarm that was set to end the stream
    CHAT_STREAM_CANCELLED_ALARM, //response is from the alarm that was sent to indicate the chat stream was cancelled (server is going down or another started w/ same oid)
    NOTIFY_WHEN_DONE //response is from the context.AsyncNotifyWhenDone() callback
};

/** This is a template type so that a forward class declaration can be avoided.
 * This will occur because CallDataCommand uses ChatStreamContainerObject and ChatStreamContainerObject uses
 * CallDataCommand.**/
template <typename T>
struct CallDataCommand {

    CallDataCommand() = delete;

    explicit CallDataCommand(CallDataCommandTypes _commandType, T* object) : commandType(_commandType), currentObject(object) {}

    const CallDataCommandTypes commandType;
    T* const currentObject;

    bool operator<(const CallDataCommand& rhs) const {
        return currentObject < rhs.currentObject;
    }

};